package worldserver

import (
	"fmt"
	"io"
	"time"

	"github.com/superp00t/etc"
	"github.com/superp00t/etc/yo"
	"github.com/superp00t/gophercraft/gcore"
	"github.com/superp00t/gophercraft/guid"
	"github.com/superp00t/gophercraft/packet"
	"github.com/superp00t/gophercraft/packet/update"
	"github.com/superp00t/gophercraft/worldserver/wdb"
)

var (
	DefaultSpeeds = update.Speeds{
		update.Walk:         2.5,
		update.Run:          7,
		update.RunBackward:  4.5,
		update.Swim:         4.722222,
		update.SwimBackward: 2.5,
		update.Turn:         3.141594,
	}
)

func (s *Session) SetupOnLogin() {
	s.State = InWorld

	s.SendVerifyLoginPacket()
	s.SendAccountDataTimes()
	s.SendRestStart()
	s.BindpointUpdate()
	s.SendTutorialFlags()
	s.SendSpellList()
	s.SendActionButtons()
	s.SendFactions()
	s.SetTimeSpeed()
	s.SpawnPlayer()
	s.BroadcastStatus(packet.FriendOnline)
	s.InitGroup()

	yo.Ok("Sent spawn packet.")

	go func() {
		time.Sleep(500 * time.Millisecond)
		s.MOTD(`G O P H E R C R A F T`)
		s.MOTD("   version %s", gcore.Version)
		s.SystemChat("|TInterface\\OptionsFrame\\NvidiaLogo:0:0:0:0:128:64:0:0:0:0|t")
	}()
}

func packTime(t time.Time) int32 {
	year, month, day := t.Date()
	tm_year := int32(year)
	tm_mon := int32(month)
	tm_mday := int32(day)
	tm_wday := int32(t.Weekday())
	tm_hour := int32(t.Hour())
	tm_min := int32(t.Minute())

	return (tm_year-100)<<24 | tm_mon<<20 | (tm_mday-1)<<14 | tm_wday<<11 | tm_hour<<6 | tm_min
}

func (s *Session) SetTimeSpeed() {
	pkt := packet.NewWorldPacket(packet.SMSG_LOGIN_SETTIMESPEED)
	pkt.WriteInt32(packTime(time.Now()))
	pkt.WriteFloat32(0.01666667)

	s.SendAsync(pkt)
}

func (s *Session) SendVerifyLoginPacket() {
	v := packet.NewWorldPacket(packet.SMSG_LOGIN_VERIFY_WORLD)

	v.WriteUint32(s.Char.Map)
	v.WriteFloat32(s.Char.X)
	v.WriteFloat32(s.Char.Y)
	v.WriteFloat32(s.Char.Z)
	v.WriteFloat32(s.Char.O)

	s.SendAsync(v)
	yo.Ok("Sent verify login packet")
}

func (s *Session) SendLoginFailure(failure packet.CharLoginResult) {
	p := packet.NewWorldPacket(packet.SMSG_CHARACTER_LOGIN_FAILED)
	result, ok := packet.CharLoginResultDescriptors[s.Build()][failure]
	if !ok {
		panic(fmt.Sprintf("no result found for %v", result))
	}
	p.WriteByte(result)
}

func (s *Session) SendRestStart() {
	v := packet.NewWorldPacket(packet.SMSG_QUEST_FORCE_REMOVE)
	v.WriteUint32(0)
	s.SendAsync(v)
}

func (s *Session) SendAccountDataTimes() {
	v := packet.NewWorldPacket(packet.SMSG_ACCOUNT_DATA_TIMES)
	for i := 0; i < 32; i++ {
		v.WriteUint32(0)
	}
	s.SendAsync(v)
}

func (s *Session) SendTutorialFlags() {
	v3 := packet.NewWorldPacket(packet.SMSG_TUTORIAL_FLAGS)
	for i := 0; i < 8; i++ {
		v3.WriteUint32(0xFFFFFFFF)
	}
	s.SendAsync(v3)
	yo.Println("Tutorial flags sent.")
}

func (s *Session) HandleAccountDataUpdate(data []byte) {
	yo.Spew(data)
}

func (s *Session) SendSpellList() {
	spl := []byte{0x0, 0x23, 0x0, 0xB, 0x56, 0x0, 0x0, 0x93, 0x54, 0x0, 0x0, 0x78, 0x50, 0x0, 0x0, 0x77, 0x50, 0x0, 0x0, 0x76, 0x50, 0x0, 0x0, 0x75, 0x50, 0x0, 0x0, 0xA5, 0x23, 0x0, 0x0, 0x76, 0x23, 0x0, 0x0, 0xC2, 0x20, 0x0, 0x0, 0x9C, 0x2, 0x0, 0x0, 0xCC, 0x0, 0x0, 0x0, 0x94, 0x54, 0x0, 0x0, 0x4E, 0x9, 0x0, 0x0, 0xAF, 0x9, 0x0, 0x0, 0x51, 0x0, 0x0, 0x0, 0x91, 0x13, 0x0, 0x0, 0xA8, 0x0, 0x0, 0x0, 0xA, 0x2, 0x0, 0x0, 0x1A, 0x59, 0x0, 0x0, 0xCB, 0x0, 0x0, 0x0, 0x66, 0x18, 0x0, 0x0, 0xEA, 0xB, 0x0, 0x0, 0x80, 0x51, 0x0, 0x0, 0x67, 0x18, 0x0, 0x0, 0x4D, 0x19, 0x0, 0x0, 0x9B, 0x13, 0x0, 0x0, 0xE3, 0x0, 0x0, 0x0, 0x85, 0x0, 0x0, 0x0, 0x4E, 0x19, 0x0, 0x0, 0xBB, 0x1C, 0x0, 0x0, 0xCB, 0x19, 0x0, 0x0, 0x25, 0xD, 0x0, 0x0, 0x62, 0x1C, 0x0, 0x0, 0x59, 0x18, 0x0, 0x0, 0x63, 0x1C, 0x0, 0x0, 0x0, 0x0}

	p := packet.NewWorldPacket(packet.SMSG_INITIAL_SPELLS)
	p.Buffer = etc.FromBytes(spl)
	s.SendAsync(p)
}

func (s *Session) SendActionButtons() {
	Buf_actionbuttons := []byte{0xCB, 0x19, 0x0, 0x0, 0x85, 0x0, 0x0, 0x0, 0xA8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9F, 0x0, 0x0, 0x80, 0x16, 0x8, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
	p := packet.NewWorldPacket(packet.SMSG_ACTION_BUTTONS)
	p.Buffer = etc.FromBytes(Buf_actionbuttons)
	s.SendAsync(p)
}

func (s *Session) SendFactions() {
	Buf_reps := []byte{0x40, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x9, 0x0, 0x0, 0x0, 0x0, 0xE, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0xE, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
	p := packet.NewWorldPacket(packet.SMSG_INITIALIZE_FACTIONS)
	p.Buffer = etc.FromBytes(Buf_reps)
	s.SendAsync(p)
}

func (s *Session) GetPlayerRace() packet.Race {
	return packet.Race(s.GetByte("Race"))
}

func (s *Session) GetLevel() int {
	return int(s.GetUint32("Level"))
}

func (s *Session) IsTrackedGUID(g guid.GUID) bool {
	s.lTrackedGUIDs.Lock()
	defer s.lTrackedGUIDs.Unlock()
	for _, v := range s.TrackedGUIDs {
		if v == g {
			return true
		}
	}
	return false
}

// SpawnPlayer initializes the player into the object manager and sends the packets needed to log the client into the world.
func (s *Session) SpawnPlayer() {
	s.WS.PlayersL.Lock()
	s.WS.PlayerList[s.PlayerName()] = s
	s.WS.PlayersL.Unlock()

	// fill out attribute fields
	s.MovementInfo = &update.MovementInfo{
		Flags: 0,
		Time:  packet.GetMSTime(),
		Position: update.Position{
			Point3: update.Point3{
				X: s.Char.X,
				Y: s.Char.Y,
				Z: s.Char.Z,
			},
			O: s.Char.O,
		},
	}
	s.MoveSpeeds = DefaultSpeeds

	var err error
	s.ValuesBlock, err = update.NewValuesBlock(
		s.Build(),
		guid.TypeMaskObject|guid.TypeMaskUnit|guid.TypeMaskPlayer,
	)

	if err != nil {
		panic(err)
	}

	s.SetGUID("GUID", s.GUID())
	s.SetFloat32("ScaleX", 1.0)
	s.SetUint32("Health", 80)
	s.SetUint32("MaxHealth", 80)
	s.SetUint32("Mana", 4143)
	s.SetUint32("MaxMana", 4143)
	s.SetUint32("Energy", 100)
	s.SetUint32("MaxRage", 1000)
	s.SetUint32("MaxEnergy", 100)
	s.SetUint32("Level", uint32(s.Char.Level))
	s.SetUint32("FactionTemplate", 1)

	s.SetByte("Race", uint8(s.Char.Race))
	s.SetByte("Class", uint8(s.Char.Class))
	s.SetByte("Gender", uint8(s.Char.Gender))
	s.SetByte("Power", PowerType(packet.Class(s.Char.Class)))

	// Player flags
	s.SetBit("PlayerControlled", true)
	s.SetBit("Resting", true)

	s.SetUint32("BaseAttackTime", 2900)
	s.SetUint32("OffhandAttackTime", 2000)

	s.SetFloat32("BoundingRadius", 1.0)
	s.SetFloat32("CombatReach", 1.0)
	s.SetUint32("DisplayID", s.WS.GetNative(packet.Race(s.Char.Race), s.Char.Gender))
	s.SetUint32("NativeDisplayID", s.WS.GetNative(packet.Race(s.Char.Race), s.Char.Gender))
	s.SetUint32("MountDisplayID", 0)

	s.SetFloat32("MinDamage", 50)
	s.SetFloat32("MaxDamage", 50)
	s.SetUint32("MinOffhandDamage", 50)
	s.SetUint32("MaxOffhandDamage", 50)

	s.SetByte("LoyaltyLevel", 0xEE)

	s.SetFloat32("ModCastSpeed", 30)

	s.SetUint32("BaseMana", 60)
	// todo: replace with bit fields
	// s.SetBit("AuraByteFlagSupportable, true)
	// s.SetBit("AuraByteFlagNoDispel, true)
	s.SetByte("AuraByteFlags", 0x08|0x20)

	s.SetInt32("AttackPower", 20)
	s.SetInt32("AttackPowerMods", 0)

	s.SetInt32("RangedAttackPower", 0)
	s.SetInt32("RangedAttackPowerMods", 0)

	s.SetFloat32("MinRangedDamage", 0)
	s.SetFloat32("MaxRangedDamage", 0)

	s.SetByte("Skin", s.Char.Skin)
	s.SetByte("Face", s.Char.Face)
	s.SetByte("HairStyle", s.Char.HairStyle)
	s.SetByte("HairColor", s.Char.HairColor)

	s.SetByte("FacialHair", s.Char.FacialHair)
	s.SetByte("BankBagSlotCount", 8)
	s.SetByte("RestState", 0x01)

	s.SetByte("Gender", s.Char.Gender)

	s.SetUint32("XP", 0)
	s.SetUint32("NextLevelXP", 2500)

	s.SetUint32ArrayValue("CharacterPoints", 0, 51)
	s.SetUint32ArrayValue("CharacterPoints", 1, 2)

	s.SetFloat32("BlockPercentage", 4.0)
	s.SetFloat32("DodgePercentage", 4.0)
	s.SetFloat32("ParryPercentage", 4.0)
	s.SetFloat32("CritPercentage", 4.0)

	s.SetUint32("RestStateExperience", 200)
	s.SetInt32("Coinage", 50000)

	s.InitInventoryManager()

	yo.Spew(s.ValuesBlock.StorageDescriptor)

	s.CurrentPhase = "main"
	s.CurrentMap = s.Char.Map
	s.ZoneID = s.Char.Zone

	// send player create packet of themself
	s.SendObjectCreate(s)

	cMap := s.Map()

	// add our player to map, and notify nearby players of their presence
	cMap.AddObject(s)

	// notify our player of nearby objects.
	cMap.NearObjects(s).Iter(func(currentObject WorldObject) {
		s.TrackedGUIDs = append(s.TrackedGUIDs, currentObject.GUID())
		s.SendObjectCreate(currentObject)
	})
}

func (s *Session) BindpointUpdate() {
	//goldshire
	p := packet.NewWorldPacket(packet.SMSG_BINDPOINTUPDATE)
	p.WriteFloat32(-8949.95)
	p.WriteFloat32(-132.493)
	p.WriteFloat32(83.5312)
	p.WriteUint32(0)
	p.WriteUint32(12)

	s.SendAsync(p)
}

func (s *Session) HandleNameQuery(e *etc.Buffer) {
	in := e.ReadUint64()

	yo.Warnf("Name query 0x%016X\n", in)

	g := guid.Classic(in)

	yo.Warn(g)

	var chars []wdb.Character

	s.WS.DB.Where("id = ?", g.Counter()).Find(&chars)
	if len(chars) == 0 {
		yo.Warn("No such data exists for", g)
		return
	}

	c := chars[0]

	resp := packet.NewWorldPacket(packet.SMSG_NAME_QUERY_RESPONSE)
	resp.WriteUint64(g.Classic())
	resp.WriteCString(c.Name)
	resp.WriteByte(0)
	resp.WriteUint32(uint32(c.Race))
	resp.WriteUint32(uint32(c.Gender))
	resp.WriteUint32(uint32(c.Class))
	s.SendAsync(resp)
}

func (s *Session) encodePackedGUID(wr io.Writer, g guid.GUID) {
	g.EncodePacked(s.Build(), wr)
}

func (ws *WorldServer) RemovePlayerFromList(name string) {
	ws.PlayersL.Lock()
	delete(ws.PlayerList, name)
	ws.PlayersL.Unlock()
}

func (s *Session) CleanupPlayer() {
	s.WS.RemovePlayerFromList(s.PlayerName())
	s.BroadcastStatus(packet.FriendOffline)

	if s.State == InWorld {
		s.Map().RemoveObject(s.GUID())
	}

	if s.Group != nil {
		s.Group.UpdateList()
		s.Group = nil
	}
}

func (s *Session) HandleLogoutRequest(b []byte) {
	if s.State != InWorld {
		return
	}

	// TODO: deny if in combat

	resp := packet.NewWorldPacket(packet.SMSG_LOGOUT_RESPONSE)
	resp.WriteUint32(0)
	resp.WriteByte(0)

	s.SendAsync(resp)
	s.CleanupPlayer()

	s.State = CharacterSelectMenu

	resp = packet.NewWorldPacket(packet.SMSG_LOGOUT_COMPLETE)
	s.SendAsync(resp)
}
